"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var matrix_1 = require("../../utils/matrix");
var vector_1 = require("../../utils/vector");
var _ = require("lodash");

var kMeans = function () {
    function kMeans(dataSet, k) {
        _classCallCheck(this, kMeans);

        this.dataSet = new matrix_1.default(dataSet);
        this.k = k;
    }

    _createClass(kMeans, [{
        key: "createCent",
        value: function createCent() {
            var _this = this;

            var n = this.dataSet.size()[1];
            var centroids = matrix_1.default.zeros(this.k, n);

            var _loop = function _loop(j) {
                var minJ = _this.dataSet.min()[j],
                    maxJ = _this.dataSet.max()[j],
                    rangeJ = maxJ - minJ;
                var randomVect = vector_1.default.rand(_this.k).map(function (v) {
                    return v * rangeJ + minJ;
                });
                centroids.forEach(function (v, i) {
                    v[j] = randomVect[i];
                });
            };

            for (var j = 0; j < n; j++) {
                _loop(j);
            }
            return centroids;
        }
    }, {
        key: "distEclud",
        value: function distEclud(vec1, vec2) {
            return Math.sqrt(_.sum(_.zipWith(vec1, vec2, function (a, b) {
                return Math.pow(a - b, 2);
            })));
        }
    }, {
        key: "cluster",
        value: function cluster() {
            var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

            var m = this.dataSet.size()[0],
                dataSet = this.dataSet.arr;
            var clusterAssment = matrix_1.default.zeros(m, 2),
                centroids = this.createCent(),
                clusterChanged = true,
                k = this.k;
            var num = 0;
            while (clusterChanged) {
                if (++num > max) {
                    break;
                }
                clusterChanged = false;
                for (var i = 0; i < m; i++) {
                    var minDist = Infinity,
                        minIndex = -1;
                    for (var j = 0; j < k; j++) {
                        var distIJ = this.distEclud(centroids[j], dataSet[i]);
                        if (distIJ < minDist) {
                            minDist = distIJ;
                            minIndex = j;
                        }
                    }
                    if (clusterAssment[i][0] !== minIndex) {
                        clusterChanged = true;
                    }
                    clusterAssment[i] = [minIndex, Math.pow(minDist, 2)];
                }

                var _loop2 = function _loop2(cent) {
                    var centPointsIndex = [];
                    clusterAssment.forEach(function (v, i) {
                        if (v[0] === cent) {
                            centPointsIndex.push(i);
                        }
                    });
                    if (centPointsIndex.length !== 0) {
                        var pointsInCent = dataSet.filter(function (v, i) {
                            return i in centPointsIndex;
                        });
                        centroids[cent] = matrix_1.default.mean(pointsInCent);
                    }
                };

                for (var cent = 0; cent < k; cent++) {
                    _loop2(cent);
                }
            }
            return [centroids, clusterAssment];
        }
    }]);

    return kMeans;
}();

exports.default = kMeans;
//# sourceMappingURL=../../maps/algorithm/kMeans/index.js.map
